# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _bmc
else:
    import _bmc

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _bmc.delete_SwigPyIterator

    def value(self):
        return _bmc.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _bmc.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _bmc.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _bmc.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _bmc.SwigPyIterator_equal(self, x)

    def copy(self):
        return _bmc.SwigPyIterator_copy(self)

    def next(self):
        return _bmc.SwigPyIterator_next(self)

    def __next__(self):
        return _bmc.SwigPyIterator___next__(self)

    def previous(self):
        return _bmc.SwigPyIterator_previous(self)

    def advance(self, n):
        return _bmc.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _bmc.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _bmc.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _bmc.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _bmc.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _bmc.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _bmc.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _bmc:
_bmc.SwigPyIterator_swigregister(SwigPyIterator)
class IntVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _bmc.IntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _bmc.IntVector___nonzero__(self)

    def __bool__(self):
        return _bmc.IntVector___bool__(self)

    def __len__(self):
        return _bmc.IntVector___len__(self)

    def __getslice__(self, i, j):
        return _bmc.IntVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _bmc.IntVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _bmc.IntVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _bmc.IntVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _bmc.IntVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _bmc.IntVector___setitem__(self, *args)

    def pop(self):
        return _bmc.IntVector_pop(self)

    def append(self, x):
        return _bmc.IntVector_append(self, x)

    def empty(self):
        return _bmc.IntVector_empty(self)

    def size(self):
        return _bmc.IntVector_size(self)

    def swap(self, v):
        return _bmc.IntVector_swap(self, v)

    def begin(self):
        return _bmc.IntVector_begin(self)

    def end(self):
        return _bmc.IntVector_end(self)

    def rbegin(self):
        return _bmc.IntVector_rbegin(self)

    def rend(self):
        return _bmc.IntVector_rend(self)

    def clear(self):
        return _bmc.IntVector_clear(self)

    def get_allocator(self):
        return _bmc.IntVector_get_allocator(self)

    def pop_back(self):
        return _bmc.IntVector_pop_back(self)

    def erase(self, *args):
        return _bmc.IntVector_erase(self, *args)

    def __init__(self, *args):
        _bmc.IntVector_swiginit(self, _bmc.new_IntVector(*args))

    def push_back(self, x):
        return _bmc.IntVector_push_back(self, x)

    def front(self):
        return _bmc.IntVector_front(self)

    def back(self):
        return _bmc.IntVector_back(self)

    def assign(self, n, x):
        return _bmc.IntVector_assign(self, n, x)

    def resize(self, *args):
        return _bmc.IntVector_resize(self, *args)

    def insert(self, *args):
        return _bmc.IntVector_insert(self, *args)

    def reserve(self, n):
        return _bmc.IntVector_reserve(self, n)

    def capacity(self):
        return _bmc.IntVector_capacity(self)
    __swig_destroy__ = _bmc.delete_IntVector

# Register IntVector in _bmc:
_bmc.IntVector_swigregister(IntVector)
class DoubleVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _bmc.DoubleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _bmc.DoubleVector___nonzero__(self)

    def __bool__(self):
        return _bmc.DoubleVector___bool__(self)

    def __len__(self):
        return _bmc.DoubleVector___len__(self)

    def __getslice__(self, i, j):
        return _bmc.DoubleVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _bmc.DoubleVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _bmc.DoubleVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _bmc.DoubleVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _bmc.DoubleVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _bmc.DoubleVector___setitem__(self, *args)

    def pop(self):
        return _bmc.DoubleVector_pop(self)

    def append(self, x):
        return _bmc.DoubleVector_append(self, x)

    def empty(self):
        return _bmc.DoubleVector_empty(self)

    def size(self):
        return _bmc.DoubleVector_size(self)

    def swap(self, v):
        return _bmc.DoubleVector_swap(self, v)

    def begin(self):
        return _bmc.DoubleVector_begin(self)

    def end(self):
        return _bmc.DoubleVector_end(self)

    def rbegin(self):
        return _bmc.DoubleVector_rbegin(self)

    def rend(self):
        return _bmc.DoubleVector_rend(self)

    def clear(self):
        return _bmc.DoubleVector_clear(self)

    def get_allocator(self):
        return _bmc.DoubleVector_get_allocator(self)

    def pop_back(self):
        return _bmc.DoubleVector_pop_back(self)

    def erase(self, *args):
        return _bmc.DoubleVector_erase(self, *args)

    def __init__(self, *args):
        _bmc.DoubleVector_swiginit(self, _bmc.new_DoubleVector(*args))

    def push_back(self, x):
        return _bmc.DoubleVector_push_back(self, x)

    def front(self):
        return _bmc.DoubleVector_front(self)

    def back(self):
        return _bmc.DoubleVector_back(self)

    def assign(self, n, x):
        return _bmc.DoubleVector_assign(self, n, x)

    def resize(self, *args):
        return _bmc.DoubleVector_resize(self, *args)

    def insert(self, *args):
        return _bmc.DoubleVector_insert(self, *args)

    def reserve(self, n):
        return _bmc.DoubleVector_reserve(self, n)

    def capacity(self):
        return _bmc.DoubleVector_capacity(self)
    __swig_destroy__ = _bmc.delete_DoubleVector

# Register DoubleVector in _bmc:
_bmc.DoubleVector_swigregister(DoubleVector)
BMC_MAX_PATH = _bmc.BMC_MAX_PATH

BMC_SERIAL_NUMBER_LEN = _bmc.BMC_SERIAL_NUMBER_LEN

BMC_USB = _bmc.BMC_USB

BMC_PCIE = _bmc.BMC_PCIE

BMC_DUMMY_DRV = _bmc.BMC_DUMMY_DRV

MAX_DM_SIZE = _bmc.MAX_DM_SIZE

BMC_DEV_ID_ANY = _bmc.BMC_DEV_ID_ANY

BMC_DEV_ID_QUERY_PROFILE = _bmc.BMC_DEV_ID_QUERY_PROFILE

DMSquareLayout = _bmc.DMSquareLayout

DMCircularLayout = _bmc.DMCircularLayout

DMLinearLayout = _bmc.DMLinearLayout

DMHexLayout = _bmc.DMHexLayout

DMLayoutCount = _bmc.DMLayoutCount

NO_ERR = _bmc.NO_ERR

ERR_UNKNOWN = _bmc.ERR_UNKNOWN

ERR_NO_HW = _bmc.ERR_NO_HW

ERR_INIT_DRIVER = _bmc.ERR_INIT_DRIVER

ERR_SERIAL_NUMBER = _bmc.ERR_SERIAL_NUMBER

ERR_MALLOC = _bmc.ERR_MALLOC

ERR_INVALID_DRIVER_TYPE = _bmc.ERR_INVALID_DRIVER_TYPE

ERR_INVALID_ACTUATOR_COUNT = _bmc.ERR_INVALID_ACTUATOR_COUNT

ERR_INVALID_LUT = _bmc.ERR_INVALID_LUT

ERR_ACTUATOR_ID = _bmc.ERR_ACTUATOR_ID

ERR_OPENFILE = _bmc.ERR_OPENFILE

ERR_NOT_IMPLEMENTED = _bmc.ERR_NOT_IMPLEMENTED

ERR_TIMEOUT = _bmc.ERR_TIMEOUT

ERR_POKE = _bmc.ERR_POKE

ERR_REGISTRY = _bmc.ERR_REGISTRY

ERR_PCIE_REGWR = _bmc.ERR_PCIE_REGWR

ERR_PCIE_REGRD = _bmc.ERR_PCIE_REGRD

ERR_PCIE_BURST = _bmc.ERR_PCIE_BURST

ERR_X64_ONLY = _bmc.ERR_X64_ONLY

ERR_PULSE_RANGE = _bmc.ERR_PULSE_RANGE

ERR_INVALID_SEQUENCE = _bmc.ERR_INVALID_SEQUENCE

ERR_INVALID_SEQUENCE_RATE = _bmc.ERR_INVALID_SEQUENCE_RATE

ERR_INVALID_DITHER_WVFRM = _bmc.ERR_INVALID_DITHER_WVFRM

ERR_INVALID_DITHER_GAIN = _bmc.ERR_INVALID_DITHER_GAIN

ERR_INVALID_DITHER_RATE = _bmc.ERR_INVALID_DITHER_RATE

ERR_BADARG = _bmc.ERR_BADARG

ERR_SEGMENT_ID = _bmc.ERR_SEGMENT_ID

ERR_INVALID_CALIBRATION = _bmc.ERR_INVALID_CALIBRATION

ERR_OUT_OF_LUT_RANGE = _bmc.ERR_OUT_OF_LUT_RANGE

ERR_DRIVER_NOT_OPEN = _bmc.ERR_DRIVER_NOT_OPEN

ERR_DRIVER_ALREADY_OPEN = _bmc.ERR_DRIVER_ALREADY_OPEN

ERR_FILE_PERMISSIONS = _bmc.ERR_FILE_PERMISSIONS

ERR_FILE_FORMAT = _bmc.ERR_FILE_FORMAT

ERR_USB_READ = _bmc.ERR_USB_READ

ERR_USB_WRITE = _bmc.ERR_USB_WRITE

ERR_USB_OTHER = _bmc.ERR_USB_OTHER

ERR_INVALID_COEFFICIENTS = _bmc.ERR_INVALID_COEFFICIENTS

BMC_LOG_ALL = _bmc.BMC_LOG_ALL

BMC_LOG_TRACE = _bmc.BMC_LOG_TRACE

BMC_LOG_DEBUG = _bmc.BMC_LOG_DEBUG

BMC_LOG_INFO = _bmc.BMC_LOG_INFO

BMC_LOG_WARN = _bmc.BMC_LOG_WARN

BMC_LOG_ERROR = _bmc.BMC_LOG_ERROR

BMC_LOG_FATAL = _bmc.BMC_LOG_FATAL

BMC_LOG_OFF = _bmc.BMC_LOG_OFF

DM_Piston = _bmc.DM_Piston

DM_XTilt = _bmc.DM_XTilt

DM_YTilt = _bmc.DM_YTilt

DM_SURFACE_DEFAULT_OPTIONS = _bmc.DM_SURFACE_DEFAULT_OPTIONS

DM_SURFACE_ABSOLUTE_DEFLECTION = _bmc.DM_SURFACE_ABSOLUTE_DEFLECTION

DM_SURFACE_BEST_EFFORT = _bmc.DM_SURFACE_BEST_EFFORT

class BmcDm(object):
    r"""


    The BmcDm class represents one BMC DM with drive electronics.  

    Create an instance of this class, then initialize it by calling open_dm()  

    After opening the connection to the driver, use send_data(), send_data_custom_mapping(), poke(), or set_segment() to set the shape of the DM.  

    Some settings may be configured on the BmcDm object prior to calling open_dm(): see set_profiles_path(), set_maps_path(), and set_calibrations_path().  

    C++ includes: BmcDm.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(BmcDm self) -> BmcDm

        BmcDm::BmcDm
        """
        _bmc.BmcDm_swiginit(self, _bmc.new_BmcDm())
    __swig_destroy__ = _bmc.delete_BmcDm

    def open_dm(self, serial_number):
        r"""
        open_dm(BmcDm self, char const * serial_number) -> int

        BmcDm::open_dm
        Open DM and driver with the specified serial number.  

        Opens the connection to the drive electronics. The necessary information (driver type, actuator count, maximum voltage, and mapping file) are read from a profile identified from the serial number.  

        For systems with multiple DMs or drive electronics, see :meth:`set_device_id()`  

        Possible errors: :const:`NO_ERR`, :const:`ERR_REGISTRY`, :const:`ERR_X64_ONLY`, :const:`ERR_INVALID_DRIVER_TYPE`, :const:`ERR_INIT_DRIVER`, :const:`ERR_NO_HW`, :const:`ERR_OPENFILE`, :const:`ERR_FILE_PERMISSIONS`, :const:`ERR_DRIVER_ALREADY_OPEN`, :const:`ERR_FILE_FORMAT`  

        :param str serial_number: 11 character serial number  

        :return: Error status.  

        """
        return _bmc.BmcDm_open_dm(self, serial_number)

    def send_data(self, data):
        r"""
        send_data(BmcDm self, DoubleVector data) -> int

        BmcDm::send_data
        Set full array of actuator command values.  

        Sends a full frame of data specified by Value Array. Value array consists of double precision numbers in the range [0,1]. Values are converted to the correct output (DAC value) internally. Values outside the above range will be rounded to the appropriate end of the range.  

        Possible errors: :const:`NO_ERR`, :const:`ERR_MALLOC`, :const:`ERR_X64_ONLY`, :const:`ERR_INVALID_DRIVER_TYPE`, :const:`ERR_NO_HW`, :const:`ERR_TIMEOUT`, :const:`ERR_PCIE_BURST`  

        :param list data: DoubleVector containing command values in the range [0,1]. Should have :meth:`num_actuators()` elements.  

        :return: Error status.  

        """
        return _bmc.BmcDm_send_data(self, data)

    def send_data_custom_mapping(self, data, mapping):
        r"""
        send_data_custom_mapping(BmcDm self, DoubleVector data, IntVector mapping) -> int

        BmcDm::send_data_custom_mapping
        Set full array of actuator command values with custom driver mapping.  

        Sends a full frame of data specified by Value Array. Value array consists of double precision numbers in the range [0,1]. Values are converted to the correct output (DAC value) internally. Values outside the above range will be rounded to the appropriate end of the range.  

        Possible errors: :const:`NO_ERR`, :const:`ERR_MALLOC`, :const:`ERR_X64_ONLY`, :const:`ERR_INVALID_DRIVER_TYPE`, :const:`ERR_NO_HW`, :const:`ERR_TIMEOUT`, :const:`ERR_PCIE_BURST`  

        :param list data: DoubleVector containing command values in the range [0,1]. Should have :meth:`num_actuators()` elements.  

        :param list mapping: IntVector containing the lookup table, or "mapping", to convert actuator numbers to driver channels. Should be at least the same size as the data.  

        :return: Error status.  

        """
        return _bmc.BmcDm_send_data_custom_mapping(self, data, mapping)

    def poke(self, actuator, data):
        r"""
        poke(BmcDm self, int actuator, double data) -> int

        BmcDm::poke
        Set the command value of a single actuator, leaving all others unchanged.  

        Sets the value of a single actuator, i.e. "poke". Only PCIe based drivers can set one actuator independently of all others without needing to send an entire frame, but the frame is buffered internally for other drivers.  

        For drivers that require a channel mapping, the last loaded LUT is used.  

        Possible errors: :const:`NO_ERR`, :const:`ERR_NOT_IMPLEMENTED`, :const:`ERR_X64_ONLY`, :const:`ERR_ACTUATOR_ID`, :const:`ERR_PCIE_REGWR`  

        :param int actuator: The actuator number to change.  

        :param double data: The actuator command value to write. This is converted to the correct DAC value internally.  

        :return: Error status.  

        """
        return _bmc.BmcDm_poke(self, actuator, data)

    def close_dm(self):
        r"""
        close_dm(BmcDm self) -> int

        BmcDm::close_dm
        Close driver connection.  

        Sets the driver output to zero before closing.  

        Possible errors: :const:`NO_ERR`, :const:`ERR_INVALID_DRIVER_TYPE`, :const:`ERR_NO_HW`, :const:`ERR_TIMEOUT`  

        :return: Error status.  

        """
        return _bmc.BmcDm_close_dm(self)

    def default_mapping(self):
        r"""
        default_mapping(BmcDm self) -> IntVector

        BmcDm::default_mapping
        Get the default driver channel mapping.  

        :return: IntVector containing the lookup table, or "mapping", to convert actuator numbers to driver channels.  

        """
        return _bmc.BmcDm_default_mapping(self)

    def get_actuator_data(self):
        r"""
        get_actuator_data(BmcDm self) -> DoubleVector

        BmcDm::get_actuator_data
        Get a copy of the full array of the last actuator command values.  

        :return: DoubleVector of command values of size :meth:`num_actuators()`  

        """
        return _bmc.BmcDm_get_actuator_data(self)

    def set_segment(self, segment, piston, xTilt, yTilt, applyOffsets, sendNow):
        r"""
        set_segment(BmcDm self, int segment, double piston, double xTilt, double yTilt, bool applyOffsets, bool sendNow) -> int

        BmcDm::set_segment
        Set the Piston, X-Tilt, Y-Tilt, of a single segment of an SLM.  

        set_segment sets the tilt and piston value of a single segment of a segmented DM. Unlike the actuator commands, the values passed to this function are in user units.  

        A calibration table must be loaded before using this function.  

        Only PCIe based drivers can set one actuator independently of all others without needing to send an entire frame. Because some devices require an entire frame for all actuator DACs, the frame is buffered internally. Use *sendNow* to control sending the frame. The internally buffered frame may be overwritten by :meth:`poke()` or :meth:`send_data()`  

        Possible errors: :const:`NO_ERR`, :const:`ERR_NOT_IMPLEMENTED`, :const:`ERR_X64_ONLY`, :const:`ERR_ACTUATOR_ID`, :const:`ERR_PCIE_REGWR`, :const:`ERR_SEGMENT_ID`, :const:`ERR_INVALID_CALIBRATION`, :const:`ERR_OUT_OF_LUT_RANGE`  

        :param int segment: The segment number to change. For square segment or continuous face-sheet mirrors, this corresponds to the actuator number.  

        :param double piston: The piston command value in nm. This is converted to the correct DAC value(s) internally.  

        :param double xTilt: The X-Tilt command value in radians. This is converted to the correct DAC value(s) internally. This is ignored for square segment or continous face-sheet mirrors.  

        :param double yTilt: The Y-Tilt command value in radians. This is converted to the correct DAC value(s) internally. This is ignored for square segment or continous face-sheet mirrors.  

        :param bool applyOffsets: Subtract the unpowered DM shape from the commanded values. This should usually be set to True. The unpowered shape is provided in the calibration table.  

        :param bool sendNow: Send the frame of data to the DACs. If 0, the frame is buffered internally until this function is called with with sendNow=1 or :meth:`poke()` is called for a device that requires an entire frame.  

        :return: Error status.  

        """
        return _bmc.BmcDm_set_segment(self, segment, piston, xTilt, yTilt, applyOffsets, sendNow)

    def get_segment_range(self, segment, axis, piston, xTilt, yTilt, applyOffsets):
        r"""
        get_segment_range(BmcDm self, int segment, DMSegmentAxis axis, double piston, double xTilt, double yTilt, bool applyOffsets) -> int

        BmcDm::get_segment_range
        Get the Piston range for a given X-Tilt, Y-Tilt or tilt range given piston.  

        get_segment_range gets the range of values of a single segment of a segmented DM given values for the other two axes. Unlike the actuator commands, the values passed to this function are in user units.  

        A calibration table must be loaded before using this function.  

        Possible errors: :const:`NO_ERR`, :const:`ERR_NOT_IMPLEMENTED`, :const:`ERR_ACTUATOR_ID`, :const:`ERR_SEGMENT_ID`, :const:`ERR_INVALID_CALIBRATION`, :const:`ERR_OUT_OF_LUT_RANGE`  

        :param segment: The segment number to query. For square segment or continuous face-sheet mirrors, this corresponds to the actuator number.  

        :param int axis: Query Piston, X-Tilt, or Y-Tilt. The given value for this axis is not used.  

        :param double piston: The piston command value in nm.  

        :param double xTilt: The X-Tilt command value in radians. This is converted to the correct DAC value(s) internally. This is ignored for square segment or continous face-sheet mirrors. This is ignored if *axis* == DM_XTilt.  

        :param double yTilt: The Y-Tilt command value in radians. This is converted to the correct DAC value(s) internally. This is ignored for square segment or continous face-sheet mirrors. This is ignored if *axis* == DM_YTilt.  

        :param bool applyOffsets: Subtract the unpowered DM shape from the commanded values. This should usually be set to True. The unpowered shape is provided in the calibration table. Use this consistently with the same parameter to :meth:`set_segment()`.  

        :return: Error status, minValue, maxValue  

        """
        return _bmc.BmcDm_get_segment_range(self, segment, axis, piston, xTilt, yTilt, applyOffsets)

    def load_calibration_file(self, filePath):
        r"""
        load_calibration_file(BmcDm self, char const * filePath) -> int

        BmcDm::load_calibration_file
        Read calibration file for user unit to DAC value conversion.  

        The calibration is only used by functions that accept user units.  

        The following file formats are supported: .MAT (MATLAB) Version 7.0  

        Possible errors: :const:`NO_ERR`, :const:`ERR_INVALID_DRIVER_TYPE`, :const:`ERR_NO_HW`, :const:`ERR_TIMEOUT`, :const:`ERR_ACTUATOR_ID`, :const:`ERR_INVALID_CALIBRATION`  

        :param str filePath: Path and name of calibration file.  

        :return: Error status.  

        """
        return _bmc.BmcDm_load_calibration_file(self, filePath)

    def num_actuators(self):
        r"""
        num_actuators(BmcDm self) -> int

        BmcDm::num_actuators
        The size of the mirror. :return: The size of the mirror.  

        """
        return _bmc.BmcDm_num_actuators(self)

    def num_actuators_width(self):
        r"""
        num_actuators_width(BmcDm self) -> int

        BmcDm::num_actuators_width
        The number of actuators across the mirror. :return: The number of actuators across the mirror.  

        """
        return _bmc.BmcDm_num_actuators_width(self)

    def get_status(self):
        r"""
        get_status(BmcDm self) -> int

        BmcDm::get_status
        The error status of the last command. :return: Error status.  

        """
        return _bmc.BmcDm_get_status(self)

    def error_string(self, error_code):
        r"""
        error_string(BmcDm self, int error_code) -> char const *

        BmcDm::error_string
        Error message for the given error code.  

        :param int error_code: Error status.  

        :return: Error message.  

        :rtype: str  

        """
        return _bmc.BmcDm_error_string(self, error_code)

    def set_profiles_path(self, profiles_path):
        r"""
        set_profiles_path(BmcDm self, char const * profiles_path) -> int

        BmcDm::set_profiles_path
        Set the path to search for driver profiles.  

        This effects future calls to :meth:`open_dm()` The default path is [Install Folder]/Profiles  

        Possible errors: :const:`NO_ERR`, :const:`ERR_REGISTRY`  

        :param str profiles_path: The path containing driver profiles.  

        :return: Error status.  

        """
        return _bmc.BmcDm_set_profiles_path(self, profiles_path)

    def set_maps_path(self, maps_path):
        r"""
        set_maps_path(BmcDm self, char const * maps_path) -> int

        BmcDm::set_maps_path
        Set the path to search for driver mappings.  

        This effects future calls to :meth:`open_dm()` The default path is [Profiles Folder]/../Map  

        Possible errors: :const:`NO_ERR`, :const:`ERR_REGISTRY`  

        :param str maps_path: The path containing driver mappings.  

        :return: Error status.  

        """
        return _bmc.BmcDm_set_maps_path(self, maps_path)

    def set_calibrations_path(self, cals_path):
        r"""
        set_calibrations_path(BmcDm self, char const * cals_path) -> int

        BmcDm::set_calibrations_path
        Set the path to search for calibration tables.  

        This effects future calls to :meth:`open_dm()` The default path is [Profiles Folder]/../Calibration  

        Possible errors: :const:`NO_ERR`, :const:`ERR_REGISTRY`  

        :param str cals_path: The path containing calibration tables.  

        :return: Error status.  

        """
        return _bmc.BmcDm_set_calibrations_path(self, cals_path)

    def configure_log(self, filePath, level):
        r"""
        configure_log(BmcDm self, char const * filePath, BMC_LOGLEVEL level) -> int

        BmcDm::configure_log
        Set the log file and log level.  

        The default log file is in the user's LOCALAPPDATA directory.  

        Call this before :meth:`open_dm()` to make sure the default file is not used. It may be called at any time to change the setting.  

        The default path is [LOCALAPPDATA]/Boston Micromachines/DM-SDK.log  

        Possible errors: :const:`NO_ERR`, :const:`ERR_REGISTRY`  

        :param str filePath: The full path of the log file.  

        :param int level: Minimum level for log messages. Set to :const:`BMC_LOG_ALL` for maximal debugging output.  

        :return: Error status.  

        """
        return _bmc.BmcDm_configure_log(self, filePath, level)

    @staticmethod
    def version_string():
        r"""
        version_string() -> char const *

        BmcDm::version_string
        Return string version number.  

        :return: Version number "X.Y.Z"  

        :rtype: str  

        """
        return _bmc.BmcDm_version_string()

    def configure_sequence(self, sequence, delay, frame_length, seq_length):
        r"""
        configure_sequence(BmcDm self, DoubleVector sequence, double delay, int frame_length, int seq_length) -> int

        BmcDm::configure_sequence
        Configure the sequencing hardware.  

        PCIe card only.  

        Configure the on board sequence functionality. Store a sequence of several DM patterns and the commands will transmit at a fixed frame rate or on the rising edge of the TTL input.  

        When the end of the sequence is reached the first pattern is repeated.  

        The delay parameter will delay the output up to 0.25 seconds after each TTL trigger.  

        The TTL or internal trigger is enabled based on the value of the framerate parameter to enable_sequence().  

        Possible errors: :const:`NO_ERR`, :const:`ERR_INVALID_DRIVER_TYPE` , :const:`ERR_INVALID_SEQUENCE`, :const:`ERR_INVALID_SEQUENCE_RATE`, :const:`ERR_PCIE_REGWR`  

        :param list sequence: array of length frame_length*seq_length. Max length is 4096 or 65536, depending on version, limited by FPGA memory.  

        :param double delay: Delay between the trigger and output of the next sequence frame. Range is [0,0.25] seconds.  

        :param int frame_length: The number of actuators in each frame, up to ActCount.  

        :param int seq_length: Number of frames.  

        :return: Error status.  

        """
        return _bmc.BmcDm_configure_sequence(self, sequence, delay, frame_length, seq_length)

    def enable_sequence(self, framerate, enable):
        r"""
        enable_sequence(BmcDm self, double framerate, bool enable) -> int

        BmcDm::enable_sequence
        Turn the sequencing functionality on or off.  

        Call configure_sequence() first.  

        Possible errors: :const:`NO_ERR`, :const:`ERR_INVALID_SEQUENCE_RATE` , :const:`ERR_PCIE_REGWR`  

        :param double framerate: Frame rate of sequence frames. If the frame rate is 0 the TTL trigger input (SMA connector) will be used to advance frames.  

        :param bool enable: True to start sequencing. False to stop.  

        :return: Error status.  

        """
        return _bmc.BmcDm_enable_sequence(self, framerate, enable)

    def configure_dither(self, waveform, gains):
        r"""
        configure_dither(BmcDm self, DoubleVector waveform, DoubleVector gains) -> int

        BmcDm::configure_dither
        Configure the dithering functionality. The waveform is the sequence of frame magnitudes and gains is the value for each actuator that will be dither on each frame. So the value actuator j in frame i will be waveform[i]*gains[j].  

        Possible errors: :const:`NO_ERR`, :const:`ERR_INVALID_DRIVER_TYPE` , :const:`ERR_INVALID_DITHER_WVFRM`, :const:`ERR_INVALID_DITHER_GAIN`, :const:`ERR_PCIE_REGWR`  

        :param list waveform: Array of dither waveform in range [0,1]. Maximum length is 2048.  

        :param list gains: Array of actuator values to be dithered. This must match the mirror size in length.  

        :return: Error status.  

        """
        return _bmc.BmcDm_configure_dither(self, waveform, gains)

    def enable_dither(self, frame_rate, enable):
        r"""
        enable_dither(BmcDm self, double frame_rate, bool enable) -> int

        BmcDm::enable_dither
        Turn the dithering functionality on or off.  

        Possible errors: :const:`NO_ERR`, :const:`ERR_INVALID_DITHER_RATE` , :const:`ERR_PCIE_REGWR`  

        :param double frame_rate: Frame rate of dither frames.  

        :param bool enable: Turns dithering on or off.  

        :return: Error status.  

        """
        return _bmc.BmcDm_enable_dither(self, frame_rate, enable)

    def enable_high_res(self, enable):
        r"""
        enable_high_res(BmcDm self, bool enable) -> int

        BmcDm::enable_high_res
        Enables high resolution dithering functionality.  

        When this mode is active the firmware logic updates all actuators continuously at the maximum rate supported by the communications link or the DAC hardware, whichever is lower. Successive commands for a given actuator are incremented by one DAC count, or not, in a pattern based on the two bits of the commanded value which are just beyond the LSB of the DAC.  

        note: All other configuration is disabled while this is enabled.  

        note: Dither hardware must be installed.  

        note: Only supported with firmware version 6.0.  

        Possible errors: :const:`NO_ERR`, :const:`ERR_INVALID_DRIVER_TYPE`, :const:`ERR_PCIE_REGRD`, :const:`ERR_PCIE_REGWR`, :const:`ERR_NOT_IMPLEMENTED`, :const:`ERR_INVALID_DITHER_RATE`, :const:`ERR_INVALID_SEQUENCE_RATE`  

        :param bool enable: True to enable high-res mode. False to disable.  

        :return: Error status.  

        """
        return _bmc.BmcDm_enable_high_res(self, enable)

    def set_device_id(self, device_id):
        r"""
        set_device_id(BmcDm self, int device_id) -> int

        BmcDm::set_device_id
        Set Device ID of driver.  

        For PCIe devices, the *device_id* field may be set to an index starting with 1 to select a PCIe interface card when more than one is installed. If set to 0 or a value higher than the number of cards, this field is ignored, except for the following special values.  

        Call this before :meth:`open_dm()`  

        If *device_id* is BMC_DEV_ID_QUERY_PROFILE, the driver is not opened and ERR_NO_HW is returned.  

        For DMs that use multiple DEs, the *device_id* refers to the first of the DEs.  

        Possible errors: :const:`NO_ERR`, :const:`ERR_BADARG`  

        :param int device_id: Device ID starting with 1.  

        :return: Error status.  

        """
        return _bmc.BmcDm_set_device_id(self, device_id)

    def calculate_surface(self, phase_map_nm, width, height, dm_diameter=0, options=DM_SURFACE_DEFAULT_OPTIONS):
        r"""
        calculate_surface(BmcDm self, DoubleVector phase_map_nm, int width, int height, int dm_diameter=0, uint32_t options=DM_SURFACE_DEFAULT_OPTIONS) -> int

        BmcDm::calculate_surface
        Calculate the DM commands for the given high resolution phase map.  

        The output commands from this function can be sent to the DM using :meth:`send_data()`  

        Possible errors: :const:`NO_ERR`, :const:`ERR_NOT_IMPLEMENTED`, :const:`ERR_INVALID_ACTUATOR_COUNT`, :const:`ERR_BADARG`, :const:`ERR_INVALID_CALIBRATION`, :const:`ERR_OUT_OF_LUT_RANGE`  

        :param list phase_map_nm: 2D array of phase values in nanometers. Length is *width*height*.  

        :param int width: Width of 2D phase array  

        :param int height: Height of 2D phase array  

        :param int dm_diameter: Diameter of active aperture of the DM in actuator spans. Set to 0 to use the recommended default aperture, which is *pMirror->ActCountWidth - 3*. Set to *pMirror->ActCountWidth - 1* to use the full DM. Fractional actuator spans are not supported. For translation to *mm*, refer to the DM datasheet.  

        :param int options: Set to 0 for default options. Bit-wise mask of the following:  

        *   :const:`DM_SURFACE_ABSOLUTE_DEFLECTION`  
        *   :const:`DM_SURFACE_BEST_EFFORT`  

        :return: Error status, command map, downsampled phase map.  

        """
        return _bmc.BmcDm_calculate_surface(self, phase_map_nm, width, height, dm_diameter, options)

    def set_surface(self, phase_map_nm, width, height, dm_diameter=0, options=DM_SURFACE_DEFAULT_OPTIONS):
        r"""
        set_surface(BmcDm self, DoubleVector phase_map_nm, int width, int height, int dm_diameter=0, uint32_t options=DM_SURFACE_DEFAULT_OPTIONS) -> int

        BmcDm::set_surface
        Calculate and send the DM commands for the given phase map.  

        This function is provided for convenience. It is equivalent to :meth:`calculate_surface()` followd by :meth:`send_data()`  

        Possible errors: :const:`NO_ERR`, :const:`ERR_NOT_IMPLEMENTED`, :const:`ERR_INVALID_ACTUATOR_COUNT`, :const:`ERR_BADARG`, :const:`ERR_INVALID_CALIBRATION`, :const:`ERR_OUT_OF_LUT_RANGE`, any error from :meth:`send_data()`  

        :param list phase_map_nm: 2D array of phase values in nanometers. Length is width*height.  

        :param int width: Width of 2D phase array  

        :param int height: Height of 2D phase array  

        :param int dm_diameter: Diameter of active aperture of the DM in actuator spans. Set to 0 to use the recommended default aperture, which is *pMirror->ActCountWidth - 3*. Set to *pMirror->ActCountWidth - 1* to use the full DM.  
         Fractional actuator spans are not supported. For translation to *mm*, refer to the DM datasheet.  

        :param int options: Set to 0 for default options. Bit-wise mask of the following:  

        *   :const:`DM_SURFACE_ABSOLUTE_DEFLECTION`  
        *   :const:`DM_SURFACE_BEST_EFFORT`  

        :return: Error status.  

        """
        return _bmc.BmcDm_set_surface(self, phase_map_nm, width, height, dm_diameter, options)

    def zernike_surface(self, Zernike_coefficients, dm_diameter=0, options=0):
        r"""
        zernike_surface(BmcDm self, DoubleVector Zernike_coefficients, int dm_diameter=0, uint32_t options=0) -> int

        BmcDm::zernike_surface
        Calculate the phase map for a given set of Zernike coefficients.  

        This phase map can then be passed to :meth:`calculate_surface()` or :meth:`set_surface()`  

        The OSA convention is used for indexing Zernike coefficients.  

        :param list Zernike_coefficients: Array of Zernike coefficients.  

        :param int dm_diameter: Diameter of active aperture of the DM in actuator spans. Set to 0 to use the recommended default aperture, which is *pMirror->ActCountWidth - 3*. Set to *pMirror->ActCountWidth - 1* to use the full DM.  
         Fractional actuator spans are not supported. For translation to *mm*, refer to the DM datasheet.  

        :param int options: Not used, set to 0.  

        :return: Error status, low resolution phase map.  

        """
        return _bmc.BmcDm_zernike_surface(self, Zernike_coefficients, dm_diameter, options)

# Register BmcDm in _bmc:
_bmc.BmcDm_swigregister(BmcDm)

